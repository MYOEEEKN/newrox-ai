<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEWROX AI - Predictor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        :root {
            /* Dark Theme Variables */
            --predictor-primary-bg: #0F172A;   /* Body background */
            --predictor-text-primary: #E2E8F0; /* Main text color */
            --predictor-accent-color: #38BDF8;  /* Sky 400 - Lighter sky for dark bg */
            --predictor-accent-hover: #0EA5E9; /* Sky 500 */
            --predictor-card-bg: #1E293B;      /* Card background */
            --predictor-border-color: #334155; /* Card border */
            
            --danger-color: #F87171;           /* Red 400 - Lighter red */
            --success-color: #34D399;         /* Emerald 400 - Lighter green */
            
            /* Info box for Device ID display - adjusted for dark theme */
            --info-bg-color: #1E293B;          /* Same as card for consistency or a slightly lighter dark shade e.g. #273349 */
            --info-text-color: #94A3B8;        /* Slate 400 - Lighter gray for info text */
            --info-border-color: #475569;      /* Slate 600 - Darker border for info box */

            /* Original Light theme variables (kept for reference, but overridden by dark theme)
            --predictor-primary-bg-light: #f8fafc; 
            --predictor-text-primary-light: #1e293b; 
            --predictor-accent-color-light: #0ea5e9; 
            --predictor-accent-hover-light: #0284c7;
            --predictor-card-bg-light: #ffffff; 
            --predictor-border-color-light: #e2e8f0; 
            --danger-color-light: #ef4444; 
            --success-color-light: #10b981; 
            --info-bg-color-light: #e0f2fe; 
            --info-text-color-light: #0c4a6e; 
            --info-border-color-light: #7dd3fc; 
            */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--predictor-primary-bg);
            color: var(--predictor-text-primary);
            margin-top: 0.5rem;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        /* Login Page Styles */
        .login-screen {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 90vh;
            padding: 1rem;
            animation: fadeInLogin 0.5s ease-out;
        }
        @keyframes fadeInLogin {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
        .login-container {
            background-color: var(--predictor-card-bg);
            padding: 2rem 2.5rem;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2); /* Slightly more pronounced shadow for dark bg */
            width: 100%;
            max-width: 420px; 
            text-align: center;
            border: 1px solid var(--predictor-border-color);
        }
        .login-title {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--predictor-accent-color);
            margin-bottom: 0.5rem;
        }
        .login-subtitle {
            font-size: 0.9rem;
            color: #94A3B8; /* Slate 400 for dark theme */
            margin-bottom: 1.5rem;
        }
        .device-id-display-container {
            background-color: var(--info-bg-color);
            border: 1px solid var(--info-border-color);
            color: var(--info-text-color);
            padding: 0.75rem 1rem;
            border-radius: 8px;
            margin-bottom: 1.5rem;
            text-align: left;
            font-size: 0.8rem;
        }
        .device-id-display-container p { margin: 0.25rem 0; }
        .device-id-display-container strong {
            font-size: 1.2em; /* Further increased font size for Device ID */
            font-weight: 700; /* Bolder */
            user-select: all; 
            cursor: pointer;
            padding: 0.2rem 0.4rem; /* More padding */
            background-color: #334155; /* Darker background for ID on info box */
            color: #E2E8F0; /* Light text for ID */
            border-radius: 4px;
            word-break: break-all;
            display: inline-block; 
        }
        .copy-device-id-btn {
            background: none;
            border: none;
            color: var(--predictor-accent-color);
            cursor: pointer;
            font-size: 0.9em;
            margin-left: 0.5rem;
            padding: 0.2rem;
        }
        .copy-device-id-btn:hover { color: var(--predictor-accent-hover); }
        .copy-feedback-inline {
            font-size: 0.75em;
            color: var(--success-color);
            margin-left: 0.5rem;
            font-weight: 500;
        }
        
        .login-status-message { 
            font-size: 0.9rem; 
            margin-top: 1.5rem; 
            min-height: 1.25rem;
            font-weight: 500;
            color: var(--predictor-text-primary); 
        }
        .login-status-message.error {
            color: var(--danger-color);
        }
        .login-status-message.success {
            color: var(--success-color);
        }
        .login-status-message.info {
            color: var(--predictor-accent-color);
        }


        .login-footer-link {
            margin-top: 1.5rem;
            font-size: 0.8rem;
            color: #94A3B8; /* Slate 400 */
        }
        .login-footer-link a {
            color: var(--predictor-accent-color);
            text-decoration: none;
            font-weight: 500;
        }
        .login-footer-link a:hover {
            text-decoration: underline;
        }

        /* Predictor Content Styles */
        .predictor-app-container {
            display: none; /* Hidden by default */
            flex-grow: 1;
            padding-bottom: 70px; /* Space for nav bar */
        }

        .nav-bar-bottom {
            position: fixed; bottom: 0; left: 0; right: 0;
            background-color: #1E293B; /* Darker nav bar */
            box-shadow: 0 -2px 10px rgba(0,0,0,0.25); /* Adjusted shadow */
            display: flex; justify-content: space-around;
            padding: 0.4rem 0.2rem; z-index: 100;
            border-top: 1px solid var(--predictor-border-color);
        }
        .nav-button {
            flex-grow: 1; text-align: center; padding: 0.5rem 0.2rem;
            border-radius: 0.375rem; font-weight: 500; font-size: 0.7rem;
            line-height: 1; transition: all 0.2s ease-in-out; cursor: pointer;
            border: 1px solid transparent; display: flex; flex-direction: column;
            align-items: center; justify-content: center; color: #94A3B8; /* Lighter text for nav items */
        }
        .nav-button i { font-size: 0.9rem; margin-bottom: 0.15rem; }
        .nav-button.active { color: var(--predictor-accent-color); background-color: #0F172A; } /* Darker active bg */
        .nav-button:not(.active):hover { background-color: #273349; color: var(--predictor-accent-hover); }

        .page { display: none; }
        .page.active { display: block; animation: fadeInPage 0.3s ease-out; }
        @keyframes fadeInPage {
            from { opacity: 0.8; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .popup, .modal {
            display: none; position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%); background: var(--predictor-card-bg); /* Use card bg for popups */
            padding: 1.25rem; border-radius: 0.625rem; 
            box-shadow: 0 8px 20px rgba(0,0,0,0.15), 0 4px 8px rgba(0,0,0,0.1);
            z-index: 1000; border: 1px solid var(--predictor-border-color);
            width: 90%; max-width: 340px;
            color: var(--predictor-text-primary); /* Ensure text color in popups is readable */
        }
        .card {
            transition: all 0.25s ease; background: var(--predictor-card-bg);
            border-radius: 0.625rem; border: 1px solid var(--predictor-border-color);
            box-shadow: 0 1px 3px rgba(0,0,0,0.1); /* Adjusted shadow for dark cards */
        }
        .card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 10px rgba(0,0,0,0.15);
        }
        .premium-badge {
            padding: 0.2rem 0.5rem; border-radius: 9999px;
            font-size: 0.65rem; font-weight: 600;
            text-transform: uppercase; letter-spacing: 0.04em; line-height: 1;
        }
        /* Badge colors might need adjustment for dark theme contrast if they were light before */
        .badge-win { background-color: #10B981; color: #064E3B; border: 1px solid #059669;} 
        .badge-loss { background-color: #F87171; color: #7F1D1D; border: 1px solid #DC2626;}
        .badge-pending { background-color: #FDBA74; color: #7C2D12; border: 1px solid #F97316;}
        .badge-api-result { background-color: #A5B4FC; color: #312E81; border: 1px solid #6366F1; }


        .animated-title-svg {
            width: 100%; max-width: 280px; height: auto;
            overflow: visible; margin: 0 auto; display: block;
        }
        .animated-title-svg text {
            text-anchor: middle; dominant-baseline: middle; text-transform: uppercase;
            animation: strokeTitleDark 5s infinite alternate; stroke-width: 1;
            stroke: var(--predictor-accent-color); font-size: 44px; font-weight: 700;
            fill: rgba(14, 165, 233, 0.1); /* Start with a subtle fill */
        }
        @keyframes strokeTitleDark { /* Adjusted for dark theme */
            0% { fill: rgba(14,165,233,0.1); stroke: var(--predictor-accent-color); stroke-dashoffset: 25%; stroke-dasharray: 0 50%; stroke-width: 1.5; }
            70% { fill: rgba(14,165,233,0.2); stroke: #38bdf8; } 
            80% { fill: rgba(14,165,233,0.3); stroke: #7dd3fc; stroke-width: 2; } 
            100% { fill: var(--predictor-accent-color); stroke: rgba(14,165,233,0.5); stroke-dashoffset: -25%; stroke-dasharray: 50% 0; stroke-width: 0; }
        }

        .history-item { transition: all 0.2s ease-in-out; border-left-width: 3px; }
        .history-item:hover { background-color: #273349; transform: translateX(3px); box-shadow: 1px 1px 6px rgba(0,0,0,0.08); } /* Darker hover */
        .history-item-win { border-color: var(--success-color); }
        .history-item-loss { border-color: var(--danger-color); }
        .history-item-pending { border-color: #f97316; } 

        .delete-btn { color: #94A3B8; transition: all 0.15s ease; } 
        .delete-btn:hover { color: var(--danger-color); transform: scale(1.05); }

        .primary-button {
            background-color: var(--predictor-accent-color); color: #0F172A; /* Dark text on light accent */
            padding: 0.4rem 0.8rem; 
            border-radius: 0.375rem; font-weight: 500; font-size: 0.8rem;
            transition: background-color 0.15s ease, box-shadow 0.15s ease;
            box-shadow: 0 1px 2px 0 rgba(0,0,0,0.05);
        }
        .primary-button:hover { background-color: var(--predictor-accent-hover); box-shadow: 0 1px 3px -1px rgba(0,0,0,0.06); }
        
        .secondary-button {
            background-color: #334155; color: #E2E8F0; padding: 0.4rem 0.8rem; /* Darker button, light text */
            border-radius: 0.375rem; font-weight: 500; font-size: 0.8rem;
            transition: background-color 0.15s ease;
        }
        .secondary-button:hover { background-color: #475569; } 
        
        #apiStatus { font-size: 0.75rem; padding: 0.2rem 0.4rem; border-radius: 0.25rem; transition: opacity 0.5s ease-out; }
        /* API Status text colors for dark theme */
        #apiStatus.bg-yellow-100 { background-color: #FDE68A !important; color: #713F12 !important; } /* Amber 200, Amber 800 */
        #apiStatus.bg-red-100 { background-color: #FECACA !important; color: #7F1D1D !important; } /* Red 200, Red 800 */
        #apiStatus.bg-green-100 { background-color: #A7F3D0 !important; color: #047857 !important; } /* Emerald 200, Emerald 700 */


        /* Global Message Bar */
        #globalMessageBar {
            display: none; 
            background-color: var(--predictor-accent-color);
            color: #0F172A; /* Dark text on light accent */
            text-align: center;
            padding: 0.5rem 1rem;
            font-size: 0.85rem;
            position: sticky; 
            top: 0;
            left: 0;
            width: 100%;
            z-index: 1001; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        #globalMessageBar p { margin: 0; }
    </style>
</head>
<body>

    <div id="loginScreen" class="login-screen">
        <div class="login-container">
            <svg class="animated-title-svg mx-auto mb-1" viewBox="0 0 400 100" style="max-width: 200px;">
                <text x="50%" y="50%">NEWROX AI</text>
            </svg>
            <h1 class="login-title">Predictor Access</h1>
            <p class="login-subtitle">Your unique Device ID is shown below.</p>
            
            <div id="deviceIdDisplayContainer" class="device-id-display-container">
                <p>Your Unique Device ID:</p>
                <p><strong id="generatedDeviceIdElement">Loading...</strong>
                   <button id="copyGeneratedIdBtn" class="copy-device-id-btn" title="Copy Device ID">
                       <i class="fas fa-copy"></i>
                   </button>
                   <span id="copyGeneratedIdFeedback" class="copy-feedback-inline" style="display:none;">Copied!</span>
                </p>
                <p class="text-xs mt-1">Provide this ID to the admin for access. The app will check for approval automatically.</p>
            </div>
            
            <div id="loginStatusMessage" class="login-status-message">
                <i class="fas fa-spinner fa-spin mr-2"></i>Initializing...
            </div>

            <p class="login-footer-link">
                Need Access? Contact <a href="https://t.me/NEWROXAI" target="_blank" rel="noopener noreferrer">Support</a>.
            </p>
        </div>
    </div>

    <div id="predictorAppContainer" class="predictor-app-container">
        <div id="globalMessageBar"><p id="globalMessageText"></p></div>

        <header class="text-center mb-3 mt-1 w-full max-w-md mx-auto">
            <svg class="animated-title-svg" viewBox="0 0 400 100">
                <text x="50%" y="50%">NEWROX AI</text>
            </svg>
            <div id="apiStatusContainer" class="text-center text-xs h-6 flex items-center justify-center">
                 <span id="apiStatus" class="bg-slate-700 text-slate-300 opacity-0">Status: Idle</span> </div>
        </header>

        <main class="w-full max-w-xl mx-auto mb-3 px-2 sm:px-0">
            <div id="page-main" class="page active">
                <div class="grid grid-cols-1 gap-3">
                    <div class="card p-3 bg-gradient-to-br from-sky-600 to-cyan-500 text-white shadow-lg"> <h2 class="text-md font-semibold mb-1.5 text-sky-200">Prediction Focus</h2>
                        <div class="grid grid-cols-2 gap-2.5 items-center">
                            <div>
                                <div class="flex items-center space-x-1 mb-0.5">
                                    <i class="fas fa-calendar-alt text-sm text-sky-300"></i>
                                    <h3 class="text-xs font-medium text-sky-300 uppercase tracking-wide">Period</h3>
                                </div>
                                <p id="currentPeriod" class="text-xl font-bold bg-slate-700/50 p-2 rounded-md text-center">-</p>
                            </div>
                            <div>
                                <div class="flex items-center space-x-1 mb-0.5">
                                    <i class="fas fa-bullseye text-sm text-sky-300"></i>
                                    <h3 class="text-xs font-medium text-sky-300 uppercase tracking-wide">Next AI Pick</h3>
                                </div>
                                <p id="currentPrediction" class="text-xl font-bold bg-slate-700/50 p-2 rounded-md text-center">-</p>
                            </div>
                        </div>
                         <div class="mt-2.5 text-center">
                            <p class="text-xs text-sky-200 uppercase tracking-wide">Last Game Result:</p>
                            <div class="flex items-center justify-center space-x-1.5 mt-0.5">
                                <p id="currentResult" class="text-md font-semibold">-</p>
                                <span id="resultIcon" class="text-lg"></span>
                            </div>
                        </div>
                         <div class="mt-1.5 text-center">
                            <p class="text-xs text-sky-200 uppercase tracking-wide">Active Logic: <span id="activeLogicDisplay" class="font-medium capitalize">-</span></p>
                        </div>
                    </div>

                    <div class="card p-3">
                        <h2 class="text-md font-semibold text-slate-300 text-center mb-3 relative"> <span class="relative z-10 bg-inherit px-1.5">Analysis Dashboard</span> <span class="absolute top-1/2 left-0 w-full h-px bg-slate-700 -translate-y-1/2"></span> </h2>
                        <div class="grid grid-cols-2 sm:grid-cols-3 gap-2.5">
                            <div class="bg-sky-700/30 p-2.5 rounded-md text-center card border-sky-600/50">
                                <p class="text-sky-400 text-[0.65rem] font-medium uppercase">Most Freq.</p>
                                <p id="mostFrequent" class="text-lg font-bold text-sky-300">-</p>
                            </div>
                            <div class="bg-sky-700/30 p-2.5 rounded-md text-center card border-sky-600/50">
                                <p class="text-sky-400 text-[0.65rem] font-medium uppercase">Least Freq.</p>
                                <p id="leastFrequent" class="text-lg font-bold text-sky-300">-</p>
                            </div>
                            <div class="bg-green-700/30 p-2.5 rounded-md text-center card border-green-600/50">
                                <p class="text-green-400 text-[0.65rem] font-medium uppercase">Win Rate</p>
                                <p id="winRate" class="text-lg font-bold text-green-300">-</p>
                            </div>
                            <div class="bg-green-700/30 p-2.5 rounded-md text-center card border-green-600/50">
                                <p class="text-green-400 text-[0.65rem] font-medium uppercase">Wins</p>
                                <p id="totalWinBets" class="text-lg font-bold text-green-300">-</p>
                            </div>
                            <div class="bg-red-700/30 p-2.5 rounded-md text-center card border-red-600/50">
                                <p class="text-red-400 text-[0.65rem] font-medium uppercase">Losses</p>
                                <p id="totalLossBets" class="text-lg font-bold text-red-300">-</p>
                            </div>
                             <div class="bg-slate-700/30 p-2.5 rounded-md card border-slate-600/50">
                                <p class="text-slate-400 text-[0.65rem] font-medium uppercase text-center">AI Win Level</p>
                                <p id="localWinLevelDisplay" class="text-lg font-bold text-slate-300 text-center">-</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="page-history" class="page">
                 <div class="card p-3">
                    <div class="flex flex-col sm:flex-row justify-between items-center mb-3 gap-2">
                        <h2 class="text-md font-semibold text-slate-300">Prediction History</h2>
                        <button id="clearHistoryBtn" class="primary-button w-full sm:w-auto text-xs">
                            <i class="fas fa-trash-alt mr-1"></i>Clear All
                        </button>
                    </div>
                    <div id="historyContainer" class="space-y-1.5 max-h-[65vh] sm:max-h-[70vh] overflow-y-auto pr-0.5">
                        <p class="text-slate-400 text-center py-5 text-sm">No history yet, or history is loading...</p>
                    </div>
                </div>
            </div>

            <div id="page-about" class="page">
                <div class="card p-3 md:p-5">
                    <h2 class="text-lg font-bold text-sky-400 mb-3 text-center">About NEWROX AI</h2>
                    <div class="space-y-2.5 text-slate-300 leading-relaxed text-xs sm:text-sm">
                        <p>Welcome to NEWROX AI, your advanced prediction assistant! This tool analyzes patterns to provide insights for informed decisions.</p>
                        <p><strong>How it Works:</strong> The system processes game data, identifies trends, and generates predictions using a proprietary algorithm. The Analysis Dashboard offers key statistics.</p>
                        <p><strong>Features:</strong> Real-time Predictions, Detailed History, Statistical Analysis, User-Friendly Interface.</p>
                        <p>This predictor learns from past results. However, all predictions are probabilistic and not guaranteed. Use responsibly.</p>
                        <p><strong>Disclaimer:</strong> For informational and entertainment purposes only. Not financial advice. Use your discretion.</p>
                        <div class="mt-5 text-center">
                            <p class="text-sm font-semibold text-slate-300">Support & Questions?</p>
                            <a href="https://t.me/NEWROXAI" target="_blank" rel="noopener noreferrer" class="mt-1 inline-block primary-button text-xs">
                                <i class="fab fa-telegram-plane mr-1"></i> Contact @NEWROXAI
                            </a>
                        </div>
                    </div>
                     <button id="predictorLogoutBtn" class="secondary-button w-full mt-6 text-sm">
                        <i class="fas fa-sign-out-alt mr-2"></i>Logout from Predictor
                    </button>
                </div>
            </div>
        </main>

        <nav class="nav-bar-bottom">
            <button class="nav-button active" data-page="main"> <i class="fas fa-chart-line"></i> <span>Predict</span> </button>
            <button class="nav-button" data-page="history"> <i class="fas fa-history"></i> <span>History</span> </button>
            <button class="nav-button" data-page="about"> <i class="fas fa-info-circle"></i> <span>About</span> </button>
        </nav>

        <div id="winRatePopup" class="popup">
            <div class="text-center">
                <i class="fas fa-trophy text-3xl text-yellow-400 mb-2.5"></i>
                <h2 class="text-lg font-bold mb-1 text-slate-300">Great Job!</h2>
                <p class="text-slate-400 text-xs">60% win rate achieved after 15 bets!<br>Consider taking a break.</p>
                <button id="closeWinPopupBtn" class="mt-3 secondary-button w-full text-xs">Close</button>
            </div>
        </div>

        <div id="clearHistoryModal" class="modal">
            <div class="text-center">
                <i class="fas fa-exclamation-triangle text-3xl text-amber-500 mb-2.5"></i>
                <h2 class="text-lg font-bold mb-1 text-slate-300">Confirm Clear History</h2>
                <p class="text-slate-400 text-xs mb-3">Are you sure? This action cannot be undone.</p>
                <div class="flex justify-center space-x-2">
                    <button id="confirmClear" class="primary-button bg-red-600 hover:bg-red-700 flex-1 text-xs">
                        <i class="fas fa-trash-alt mr-0.5"></i> Yes, Clear
                    </button>
                    <button id="cancelClear" class="secondary-button flex-1 text-xs">
                        <i class="fas fa-times mr-0.5"></i> No, Cancel
                    </button>
                </div>
            </div>
        </div>
    </div> <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>

    <script>
        // --- Firebase Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyDCGgg1TgPjkTNkx5NUSFdDCduRf1uSba4", // Replace with your actual API key
            authDomain: "newrox-ai.firebaseapp.com",
            databaseURL: "https://newrox-ai-default-rtdb.firebaseio.com",
            projectId: "newrox-ai",
            storageBucket: "newrox-ai.appspot.com",
            messagingSenderId: "521506398161",
            appId: "1:521506398161:web:ca6a684b6616bbb3000af0",
            measurementId: "G-LH2B2C3HLL"
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();

        // --- DOM Elements ---
        const loginScreen = document.getElementById('loginScreen');
        const predictorAppContainer = document.getElementById('predictorAppContainer');
        const loginStatusMessageEl = document.getElementById('loginStatusMessage'); 
        const predictorLogoutBtn = document.getElementById('predictorLogoutBtn');
        const globalMessageBar = document.getElementById('globalMessageBar');
        const globalMessageText = document.getElementById('globalMessageText');
        const generatedDeviceIdElement = document.getElementById('generatedDeviceIdElement');
        const copyGeneratedIdBtn = document.getElementById('copyGeneratedIdBtn');
        const copyGeneratedIdFeedback = document.getElementById('copyGeneratedIdFeedback');

        // --- Predictor Auth State ---
        const USER_DEVICE_ID_STORAGE_KEY = 'userGeneratedDeviceId_NewRoxAI'; 
        const PREDICTOR_LOGGED_IN_DEVICE_ID_KEY = 'predictorLoggedInDeviceId_NewRoxAI'; 
        let isPredictorServerOn = true; 
        let currentGlobalMessageId = null;
        let autoLoginInterval = null; 
        const AUTO_LOGIN_CHECK_INTERVAL = 7000; // Check every 7 seconds


        // --- START Global Variables & Configuration (from original main.html) ---
        const APP_STORAGE_PREFIX = 'newrox_ai_predictor_';
        let allHistory = JSON.parse(localStorage.getItem(APP_STORAGE_PREFIX + 'allHistory')) || [];
        let currentAIPrediction = JSON.parse(localStorage.getItem(APP_STORAGE_PREFIX + 'currentAIPrediction')) || null;
        let localWinLevel = parseInt(localStorage.getItem(APP_STORAGE_PREFIX + 'localWinLevel')) || 0;
        let lastAPIFetchedPeriodFull = localStorage.getItem(APP_STORAGE_PREFIX + 'lastAPIFetchedPeriodFull') || null;
        
        let moduleEffectiveness = JSON.parse(localStorage.getItem(APP_STORAGE_PREFIX + 'moduleEffectiveness')) || {
            Trend: { wins: 0, losses: 0, weightMultiplier: 1.0 },
            Dominance: { wins: 0, losses: 0, weightMultiplier: 1.0 },
            Recency: { wins: 0, losses: 0, weightMultiplier: 1.0 },
            CP: { wins: 0, losses: 0, weightMultiplier: 1.0 }, 
            Rhythm: { wins: 0, losses: 0, weightMultiplier: 1.0 }
        };
        const EFFECTIVENESS_MEMORY = 15; 
        const MAX_HISTORY_ITEMS_DISPLAY = 50; 
        const MAX_HISTORY_ITEMS_STORAGE = 100; 
        const API_FETCH_INTERVAL = 7000; 
        const MAX_WIN_LEVEL_STREAK = 2; 
        let isUpdatingData = false; 
        let apiStatusTimeoutId = null;
        // --- END Global Variables & Configuration ---

        // --- START DOM Element References (from original main.html) ---
        const pageButtons = document.querySelectorAll('.nav-button');
        const pages = document.querySelectorAll('.page');
        const currentPeriodEl = document.getElementById('currentPeriod');
        const currentResultEl = document.getElementById('currentResult');
        const currentPredictionEl = document.getElementById('currentPrediction');
        const resultIconEl = document.getElementById('resultIcon');
        const activeLogicDisplayEl = document.getElementById('activeLogicDisplay');
        const mostFrequentEl = document.getElementById('mostFrequent');
        const leastFrequentEl = document.getElementById('leastFrequent');
        const winRateEl = document.getElementById('winRate');
        const totalWinBetsEl = document.getElementById('totalWinBets');
        const totalLossBetsEl = document.getElementById('totalLossBets');
        const localWinLevelDisplayEl = document.getElementById('localWinLevelDisplay');
        const historyContainerEl = document.getElementById('historyContainer');
        const clearHistoryBtn = document.getElementById('clearHistoryBtn');
        const winRatePopup = document.getElementById('winRatePopup');
        const closeWinPopupBtn = document.getElementById('closeWinPopupBtn');
        const clearHistoryModal = document.getElementById('clearHistoryModal');
        const confirmClearBtn = document.getElementById('confirmClear');
        const cancelClearBtn = document.getElementById('cancelClear');
        const apiStatusEl = document.getElementById('apiStatus');
        // --- END DOM Element References ---

        const DEFAULT_PREDICTION_ITEM_STRUCTURE = {
            id: null, period: null, fullPeriod: null, predictionTime: null, 
            prediction: null, predictionType: "BIG/SMALL", oppositeNumber: null, 
            confidence: 0, logic: "N/A", result: null, resultType: null, 
            resultColor: null, status: "Pending", 
        };

        // --- Device ID Generation and Management ---
        function generateUniqueId() {
            return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
                (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
            );
        }

        function getOrGenerateUserDeviceId() {
            let userDeviceId = localStorage.getItem(USER_DEVICE_ID_STORAGE_KEY);
            if (!userDeviceId) {
                userDeviceId = "NEWROX-USER-" + generateUniqueId().substring(0,12).toUpperCase();
                localStorage.setItem(USER_DEVICE_ID_STORAGE_KEY, userDeviceId);
            }
            if (generatedDeviceIdElement) {
                 generatedDeviceIdElement.textContent = userDeviceId;
            }
            return userDeviceId;
        }
        
        function copyGeneratedDeviceId() {
            const deviceIdToCopy = generatedDeviceIdElement.textContent;
            // Use document.execCommand as primary due to iFrame restrictions
            const textArea = document.createElement("textarea");
            textArea.value = deviceIdToCopy;
            textArea.style.position = "fixed"; // Prevent scrolling to bottom
            textArea.style.top = "0";
            textArea.style.left = "0";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    copyGeneratedIdFeedback.style.display = 'inline';
                    setTimeout(() => { copyGeneratedIdFeedback.style.display = 'none'; }, 2000);
                } else {
                    console.error('Fallback copy was unsuccessful.');
                    alert('Failed to copy Device ID. Please copy it manually.');
                }
            } catch (err) {
                console.error('Fallback copy failed:', err);
                alert('Failed to copy Device ID. Please copy it manually.');
            }
            document.body.removeChild(textArea);
        }


        function updateLoginStatusMessage(message, type = 'info') {
            if (loginStatusMessageEl) {
                loginStatusMessageEl.innerHTML = message; 
                loginStatusMessageEl.className = 'login-status-message'; 
                if (type === 'error') {
                    loginStatusMessageEl.classList.add('error');
                } else if (type === 'success') {
                    loginStatusMessageEl.classList.add('success');
                } else { 
                    loginStatusMessageEl.classList.add('info');
                }
            }
        }

        // --- Predictor Login/Logout and State Management ---
        function checkPredictorLoginStatus() {
            getOrGenerateUserDeviceId(); 
            
            fetchPredictorServerStatus().then(() => { 
                const loggedInDeviceId = localStorage.getItem(PREDICTOR_LOGGED_IN_DEVICE_ID_KEY);
                if (loggedInDeviceId && isPredictorServerOn) { 
                    console.log("Previously logged-in Device ID found, attempting validation...");
                    attemptAutoLogin(loggedInDeviceId); 
                } else if (isPredictorServerOn) { 
                    updateLoginStatusMessage('<i class="fas fa-spinner fa-spin mr-2"></i>Checking access status...', 'info');
                    attemptAutoLogin(); 
                } else if (!isPredictorServerOn) {
                     updateLoginStatusMessage('Predictor is currently offline. Please try again later.', 'error');
                }
            });
            fetchGlobalMessage(); 

            if (autoLoginInterval) clearInterval(autoLoginInterval); 
            autoLoginInterval = setInterval(() => {
                // Only attempt auto-login if the login screen is visible and no successful login yet
                if (loginScreen.style.display === 'flex' && !localStorage.getItem(PREDICTOR_LOGGED_IN_DEVICE_ID_KEY)) { 
                    console.log("Periodic auto-login check...");
                    attemptAutoLogin();
                } else if (localStorage.getItem(PREDICTOR_LOGGED_IN_DEVICE_ID_KEY) && autoLoginInterval) {
                    // If logged in, clear the interval
                    clearInterval(autoLoginInterval);
                    autoLoginInterval = null;
                    console.log("User logged in, auto-check interval cleared.");
                }
            }, AUTO_LOGIN_CHECK_INTERVAL);
        }

        async function attemptAutoLogin(deviceIdToLogin = null) {
            const currentDeviceId = deviceIdToLogin || getOrGenerateUserDeviceId(); 

            if (!isPredictorServerOn) {
                if (loginScreen.style.display === 'flex'){
                    updateLoginStatusMessage('Predictor is currently offline. Please try again later.', 'error');
                }
                return;
            }
            
            // Only show spinner if login screen is visible and we are not already showing success
            if (loginScreen.style.display === 'flex' && 
                (!loginStatusMessageEl.innerHTML.includes('fa-spinner') && 
                 !loginStatusMessageEl.innerHTML.includes('Access granted'))) {
                 updateLoginStatusMessage('<i class="fas fa-sync-alt fa-spin mr-2"></i>Verifying access...', 'info');
            }

            try {
                const accessKeysSnapshot = await db.ref("accessKeys").orderByChild("deviceId").equalTo(currentDeviceId).once("value");
                
                if (accessKeysSnapshot.exists()) {
                    let isValidDevice = false;
                    let isExpired = false;
                    accessKeysSnapshot.forEach(childSnapshot => {
                        const keyData = childSnapshot.val();
                        if (keyData.deviceId === currentDeviceId) {
                            if (!keyData.expiry || Date.now() < keyData.expiry) {
                                isValidDevice = true;
                            } else {
                                isExpired = true;
                            }
                        }
                    });

                    if (isValidDevice) {
                        localStorage.setItem(PREDICTOR_LOGGED_IN_DEVICE_ID_KEY, currentDeviceId);
                        showPredictorApp();
                        if (autoLoginInterval) {
                            clearInterval(autoLoginInterval);
                            autoLoginInterval = null;
                        }
                        console.log(`Auto-login successful for Device ID: ${currentDeviceId}.`);
                    } else if (isExpired) {
                        if (loginScreen.style.display === 'flex') {
                            updateLoginStatusMessage('Your access for this Device ID has expired. Contact admin.', 'error');
                        }
                        // Do not call handlePredictorLogout here if it's just an expired check during periodic scan,
                        // unless they were previously logged in with this ID.
                        if (localStorage.getItem(PREDICTOR_LOGGED_IN_DEVICE_ID_KEY) === currentDeviceId) {
                           handlePredictorLogout('Your access has expired.'); 
                        }
                    } else {
                        if (loginScreen.style.display === 'flex') {
                            updateLoginStatusMessage('Waiting for admin approval for this Device ID.', 'info');
                        }
                    }
                } else {
                     if (loginScreen.style.display === 'flex') {
                        updateLoginStatusMessage('Device ID not registered. Please provide it to the admin.', 'info');
                     }
                }
            } catch (error) {
                console.error("Predictor auto-login error:", error);
                if (loginScreen.style.display === 'flex') {
                    updateLoginStatusMessage('Error checking access. Please try refreshing.', 'error');
                }
            }
        }

        function handlePredictorLogout(message = "You have been logged out.") {
            const wasLoggedIn = !!localStorage.getItem(PREDICTOR_LOGGED_IN_DEVICE_ID_KEY);
            localStorage.removeItem(PREDICTOR_LOGGED_IN_DEVICE_ID_KEY);
            
            showPredictorLoginScreen();
            getOrGenerateUserDeviceId(); 
            updateLoginStatusMessage(message, 'info');
            console.log("Logged out from predictor.");

            if (wasLoggedIn && !autoLoginInterval) { 
                 autoLoginInterval = setInterval(() => {
                    if (loginScreen.style.display === 'flex' && !localStorage.getItem(PREDICTOR_LOGGED_IN_DEVICE_ID_KEY)) {
                        console.log("Periodic auto-login check after logout...");
                        attemptAutoLogin();
                    } else if (localStorage.getItem(PREDICTOR_LOGGED_IN_DEVICE_ID_KEY) && autoLoginInterval) {
                        clearInterval(autoLoginInterval);
                        autoLoginInterval = null;
                    }
                }, AUTO_LOGIN_CHECK_INTERVAL);
            }
        }

        function showPredictorLoginScreen() {
            loginScreen.style.display = 'flex';
            predictorAppContainer.style.display = 'none';
        }

        function showPredictorApp() {
            loginScreen.style.display = 'none';
            predictorAppContainer.style.display = 'block';
            updateUI(); 
            updateGameData(); 
            fetchGlobalMessage(); 
        }

        async function fetchPredictorServerStatus() {
            try {
                const serverStatusRef = db.ref("predictorServerStatus");
                const snapshot = await serverStatusRef.get(); 
                const serverData = snapshot.val() || { status: "on" };
                isPredictorServerOn = serverData.status === "on";
                console.log("Initial Predictor Server Status:", isPredictorServerOn ? "ON" : "OFF");

                serverStatusRef.on("value", snapshot => {
                    const updatedServerData = snapshot.val() || { status: "on" };
                    const serverBecameOffline = isPredictorServerOn && updatedServerData.status === "off";
                    const serverBecameOnline = !isPredictorServerOn && updatedServerData.status === "on";

                    isPredictorServerOn = updatedServerData.status === "on";
                    console.log("Predictor Server Status Changed To:", isPredictorServerOn ? "ON" : "OFF");

                    const isLoggedIn = !!localStorage.getItem(PREDICTOR_LOGGED_IN_DEVICE_ID_KEY);

                    if (serverBecameOffline && isLoggedIn) {
                        console.log("Server went offline while user was logged in. Logging out.");
                        alert("The predictor has been turned off by the administrator. You have been logged out.");
                        handlePredictorLogout("Predictor is now offline. You've been logged out.");
                    } else if (serverBecameOnline && !isLoggedIn) {
                        console.log("Server came online. Attempting auto-login.");
                        updateLoginStatusMessage('<i class="fas fa-spinner fa-spin mr-2"></i>Server is online. Checking access...', 'info');
                        attemptAutoLogin();
                    } else if (!isPredictorServerOn && !isLoggedIn) {
                         if (loginScreen.style.display === 'flex') { // Only update if login screen is visible
                            updateLoginStatusMessage('Predictor is currently offline by admin.', 'error');
                         }
                    }
                });
            } catch (error) {
                 console.error("Error fetching initial predictor server status:", error);
                 updateLoginStatusMessage('Could not verify predictor status. Please refresh.', 'error');
                 isPredictorServerOn = false; 
                 showPredictorLoginScreen();
            }
        }


        function fetchGlobalMessage() { /* ... (same as original) ... */
            const messageRef = db.ref("predictorGlobalMessage");
            messageRef.on("value", snapshot => {
                const messageData = snapshot.val();
                if (messageData && messageData.message && messageData.id !== currentGlobalMessageId) {
                    globalMessageText.textContent = messageData.message;
                    globalMessageBar.style.display = 'block';
                    currentGlobalMessageId = messageData.id; 
                } else if (!messageData || !messageData.message) {
                    globalMessageBar.style.display = 'none';
                    currentGlobalMessageId = null;
                }
            }, error => {
                console.error("Error fetching global message:", error);
                globalMessageBar.style.display = 'none';
            });
        }
        function switchPage(pageId) { /* ... (same as original) ... */
            pages.forEach(page => page.classList.remove('active'));
            const targetPage = document.getElementById(`page-${pageId}`);
            if (targetPage) targetPage.classList.add('active');
            else document.getElementById('page-main').classList.add('active'); 

            pageButtons.forEach(button => {
                button.classList.remove('active');
                if (button.dataset.page === pageId) button.classList.add('active');
            });
            localStorage.setItem(APP_STORAGE_PREFIX + 'active_tab', pageId);
        }
        async function fetchGameResultFromAPI() { /* ... (same as original) ... */
            updateAPIStatus("Fetching...", "bg-yellow-100 text-yellow-600", false); 
            try {
                const cacheBuster = `cb=${new Date().getTime()}`;
                const apiUrl = `https://api.bdg88zf.com/api/webapi/GetNoaverageEmerdList?${cacheBuster}`; 

                const response = await fetch(apiUrl, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        pageSize: 10, pageNo: 1, typeId: 1, language: 0,
                        random: "4a0522c6ecd8410496260e686be2a57c", 
                        signature: "334B5E70A0C9B8918B0B15E517E2069C", 
                        timestamp: Math.floor(Date.now() / 1000)
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`API Error: ${response.status} - ${errorText}`);
                    updateAPIStatus(`Error: ${response.status}`, "bg-red-100 text-red-600", true);
                    return null;
                }
                const data = await response.json();

                if (!data || typeof data !== 'object' || !data.data || typeof data.data !== 'object' || !Array.isArray(data.data.list)) {
                    console.error("API Error: Invalid data structure.", data);
                    updateAPIStatus("Invalid API Data", "bg-red-100 text-red-600", true);
                    return null;
                }
                updateAPIStatus("Live", "bg-green-100 text-green-600", true); 
                return data.data.list; 
            } catch (e) {
                console.error("Fetch API Error:", e);
                updateAPIStatus("Fetch Failed", "bg-red-100 text-red-600", true);
                return null;
            }
        }
        function updateAPIStatus(message, styleClass, autoHide) { /* ... (same as original) ... */
             if (apiStatusEl) {
                apiStatusEl.textContent = `API: ${message}`;
                apiStatusEl.className = `text-xs px-1.5 py-0.5 rounded-md ${styleClass} opacity-100`;
                if (apiStatusTimeoutId) clearTimeout(apiStatusTimeoutId);
                if (autoHide) {
                    apiStatusTimeoutId = setTimeout(() => {
                        if (apiStatusEl) apiStatusEl.classList.add('opacity-0');
                    }, 2000); 
                }
            }
        }
        function getOppositeNumber(prediction) { /* ... (same as original) ... */
            const small = [0, 1, 2, 3, 4]; const big = [5, 6, 7, 8, 9];
            let arr = prediction === "BIG" ? small : big;
            return arr[Math.floor(Math.random() * arr.length)];
        }
        function detailedTrendAnalysisModule(recentHistory, windowSize = 7) { /* ... (same as original) ... */
            const historySlice = recentHistory.slice(0, windowSize);
            if (historySlice.length < 2) return { prediction: null, confidence: 0.3, weight: 1.6, type: "Trend", logic: "Tr-Insuff" }; // Higher base weight

            let currentStreak = 0;
            let currentStreakType = null;
            if (historySlice.length > 0 && historySlice[0].resultType) {
                currentStreakType = historySlice[0].resultType;
                currentStreak = 1;
                for (let i = 1; i < historySlice.length; i++) {
                    if (historySlice[i].resultType === currentStreakType) currentStreak++;
                    else break;
                }
            }

            let alternations = 0;
            if (historySlice.length >= 2) {
                for (let i = 0; i < historySlice.length - 1; i++) {
                    if (historySlice[i].resultType && historySlice[i+1].resultType && historySlice[i].resultType !== historySlice[i+1].resultType) alternations++;
                    else break; 
                }
            }
            
            let prediction = null;
            let confidence = 0.45; // Slightly higher base confidence for trend signals
            let logic = `Tr(S${currentStreak}${currentStreakType ? currentStreakType[0] : ''}A${alternations})`;

            if (currentStreak >= 3) { 
                prediction = currentStreakType; 
                confidence = 0.72 + Math.min(0.23, (currentStreak - 3) * 0.08); 
            } else if (currentStreak === 2) { 
                prediction = currentStreakType; 
                confidence = 0.65;
            } else if (alternations >= 3) { 
                prediction = historySlice[0].resultType === "BIG" ? "SMALL" : "BIG"; 
                confidence = 0.70 + Math.min(0.20, (alternations - 2) * 0.07);
            } else if (alternations === 2) { 
                 prediction = historySlice[0].resultType === "BIG" ? "SMALL" : "BIG"; 
                 confidence = 0.62;
            } else if (currentStreak === 1 && alternations === 0 && historySlice.length >=2 && historySlice[0].resultType !== historySlice[1].resultType) { 
                 prediction = historySlice[0].resultType === "BIG" ? "SMALL" : "BIG"; 
                 confidence = 0.58;
            } else if (currentStreak === 1 && historySlice.length === 1) { 
                prediction = historySlice[0].resultType === "BIG" ? "SMALL" : "BIG"; 
                confidence = 0.52;
            }
            
            return { prediction, confidence: parseFloat(confidence.toFixed(2)), weight: 1.6 * (moduleEffectiveness.Trend?.weightMultiplier || 1.0), type: "Trend", logic };
        }
        function dominanceAnalysisModule(recentHistory, windowSize = 10, baseWeight = 1.0) { /* ... (same as original) ... */
            const historySlice = recentHistory.slice(0, windowSize);
            if (historySlice.length < windowSize / 2) return { prediction: null, confidence: 0.3, weight: baseWeight, type: "Dominance", logic: `Dom${windowSize}-Insuff` };
            
            const bigCount = historySlice.filter(h => h.resultType === "BIG").length;
            const smallCount = historySlice.filter(h => h.resultType === "SMALL").length;
            const total = bigCount + smallCount;
            if (total === 0) return { prediction: null, confidence: 0.3, weight: baseWeight, type: "Dominance", logic: `Dom${windowSize}-NoBS` };
            
            const dominanceFactor = total > 0 ? (Math.max(bigCount, smallCount) / total) : 0.5; 
            let dominantType = null;
            if (bigCount > smallCount) dominantType = "BIG";
            else if (smallCount > bigCount) dominantType = "SMALL";

            let prediction = dominantType; 
            let confidence = 0.42 + (dominanceFactor - 0.5) * 0.85; 
            if (!dominantType) confidence = 0.3; 

            return { prediction, confidence: parseFloat(confidence.toFixed(2)), weight: baseWeight * (moduleEffectiveness.Dominance?.weightMultiplier || 1.0), type: "Dominance", logic: `Dom${windowSize}(${dominantType ? dominantType[0] : 'E'}${dominanceFactor.toFixed(1)})` };
        }
        function recencyBiasAnalysisModule(recentHistory) { /* ... (same as original) ... */
            if (recentHistory.length === 0 || !recentHistory[0].resultType) return { prediction: null, confidence: 0.3, weight: 1.4, type: "Recency", logic: "Rec-Empty" }; // Higher weight
            
            const last1 = recentHistory[0].resultType;
            let prediction = last1; 
            let confidence = 0.60; // Higher base for recency
            let last2 = null; 

            if (recentHistory.length >= 2 && recentHistory[1].resultType) {
                last2 = recentHistory[1].resultType; 
                if (last1 === last2) { 
                    prediction = last1; confidence = 0.70; 
                } else { 
                    prediction = last1; confidence = 0.65; 
                }
            }
             if (recentHistory.length >= 3 && recentHistory[2].resultType && last2 !== null) { 
                const last3 = recentHistory[2].resultType;
                if (last1 === last2 && last1 === last3) { 
                    prediction = last1; confidence = 0.78; 
                } else if (last1 !== last2 && last1 === last3) { 
                     prediction = last2; confidence = 0.72; 
                }
            }
            const l1Char = last1 ? last1[0] : 'N';
            const l2Char = last2 ? last2[0] : '';
            const l3Char = (recentHistory.length >=3 && recentHistory[2].resultType) ? recentHistory[2].resultType[0] : '';

            return { prediction, confidence: parseFloat(confidence.toFixed(2)), weight: 1.4 * (moduleEffectiveness.Recency?.weightMultiplier || 1.0), type: "Recency", logic: `Rec(${l1Char}${l2Char}${l3Char})` };
        }
        function volatilityAndConsistencyModule(recentHistory, windowSize = 8) { /* ... (same as original) ... */
            const historySlice = recentHistory.slice(0, windowSize);
            if (historySlice.length < 2) return { volatilityScore: 0.5, consistencyStreak: 0, type: "Volatility", logic: "Vol-Insuff" };

            let changes = 0;
            for (let i = 0; i < historySlice.length - 1; i++) {
                if (historySlice[i].resultType && historySlice[i+1].resultType && historySlice[i].resultType !== historySlice[i+1].resultType) {
                    changes++;
                }
            }
            const volatilityScore = changes / (historySlice.length - 1);

            let consistencyStreak = 0;
            if (historySlice.length > 0 && historySlice[0].resultType) {
                const lastType = historySlice[0].resultType;
                for (const item of historySlice) {
                    if (item.resultType === lastType) consistencyStreak++;
                    else break;
                }
            }
            return { volatilityScore: parseFloat(volatilityScore.toFixed(2)), consistencyStreak, type: "Volatility", logic: `Vol(V${volatilityScore.toFixed(1)}C${consistencyStreak})` };
        }
        function complexPatternDetectorModule(recentHistory, windowSize = 6) { /* ... (same as original) ... */
            const historySlice = recentHistory.slice(0, windowSize).map(h => h.resultType).filter(Boolean); 
            if (historySlice.length < 3) return { prediction: null, confidence: 0.3, weight: 1.25, type: "CP", logic: "CP-Insuff" }; // Min 3 for CP

            const s = historySlice.join(''); 
            let prediction = null;
            let confidence = 0;
            let logic = "CP-None";

            // Prioritize longer, more distinct patterns
            if (s.startsWith("BBSS")) { prediction = "BIG"; confidence = 0.72; logic = "CP:BBSS>B"; }
            else if (s.startsWith("SSBB")) { prediction = "SMALL"; confidence = 0.72; logic = "CP:SSBB>S"; }
            else if (s.startsWith("BSSB")) { prediction = "SMALL"; confidence = 0.70; logic = "CP:BSSB>S"; }
            else if (s.startsWith("SBBS")) { prediction = "BIG"; confidence = 0.70; logic = "CP:SBBS>B"; }
            else if (s.startsWith("BBBS")) { prediction = "SMALL"; confidence = 0.75; logic = "CP:BBBS>S_Brk"; } 
            else if (s.startsWith("SSSB")) { prediction = "BIG"; confidence = 0.75; logic = "CP:SSSB>B_Brk"; }  
            else if (s.startsWith("BSBS")) { prediction = "BIG"; confidence = 0.68; logic = "CP:BSBS>B_Alt"; } 
            else if (s.startsWith("SBSB")) { prediction = "SMALL"; confidence = 0.68; logic = "CP:SBSB>S_Alt"; }
            else if (s.startsWith("BBSB")) { prediction = "BIG"; confidence = 0.65; logic = "CP:BBSB>B"; } 
            else if (s.startsWith("SSBS")) { prediction = "SMALL"; confidence = 0.65; logic = "CP:SSBS>S"; }
            // 3-length patterns (lower confidence, act as secondary signals)
            else if (s.startsWith("BSB")) { prediction = "SMALL"; confidence = 0.60; logic = "CP:BSB>S_Alt3"; } 
            else if (s.startsWith("SBS")) { prediction = "BIG"; confidence = 0.60; logic = "CP:SBS>B_Alt3"; }
            else if (s.startsWith("BBB") && historySlice.length >=3) { prediction = "SMALL"; confidence = 0.62; logic = "CP:BBB>S_Brk3"; } 
            else if (s.startsWith("SSS") && historySlice.length >=3) { prediction = "BIG"; confidence = 0.62; logic = "CP:SSS>B_Brk3"; }
            else if (s.startsWith("BB") && historySlice.length === 2) { prediction = "BIG"; confidence = 0.55; logic = "CP:BB>B_Cont2";} // Simple double follow
            else if (s.startsWith("SS") && historySlice.length === 2) { prediction = "SMALL"; confidence = 0.55; logic = "CP:SS>S_Cont2";}


            return { prediction, confidence: parseFloat(confidence.toFixed(2)), weight: 1.25 * (moduleEffectiveness.CP?.weightMultiplier || 1.0), type: "CP", logic };
        }
        function rhythmAndCycleAnalysisModule(recentHistory, windowSize = 15) { /* ... (same as original) ... */
            const historySlice = recentHistory.slice(0, windowSize);
            if (historySlice.length < 5) return { phase: "UNCLEAR", confidence: 0.4, weight: 0.7, type: "Rhythm", logic: "Rhy-Insuff" };

            let alternations = 0;
            let streaksOfTwo = 0;
            let streaksOfThreePlus = 0;

            for (let i = 0; i < historySlice.length - 1; i++) {
                if (historySlice[i].resultType && historySlice[i+1].resultType) {
                    if (historySlice[i].resultType !== historySlice[i+1].resultType) alternations++;
                    else { // Start of a potential streak
                        if (i + 2 < historySlice.length && historySlice[i+1].resultType === historySlice[i+2].resultType) {
                            streaksOfThreePlus++;
                            i += 2; // Skip checked items
                        } else {
                            streaksOfTwo++;
                            i += 1; // Skip checked item
                        }
                    }
                }
            }
            const alternationRatio = alternations / (historySlice.length -1);
            let phase = "MIXED";
            let confidence = 0.5;

            if (alternationRatio > 0.65) { phase = "CHOPPY"; confidence = 0.65; } // Highly alternating
            else if (streaksOfThreePlus > streaksOfTwo && streaksOfThreePlus > alternations / 2) { phase = "STREAKY"; confidence = 0.65; } // More long streaks
            else if (streaksOfTwo > streaksOfThreePlus && streaksOfTwo > alternations / 2) { phase = "SHORT_STREAKS"; confidence = 0.60;}
            
            return { phase, confidence: parseFloat(confidence.toFixed(2)), weight: 0.7 * (moduleEffectiveness.Rhythm?.weightMultiplier || 1.0), type: "Rhythm", logic: `Rhy(${phase})` };
        }
        function getWeightedEnsemblePrediction(signals, volatilityContext, rhythmContext, isExtremeLevelReached, streakTypeToBreak) { /* ... (same as original) ... */
            let bigScore = 0;
            let smallScore = 0;
            let logicParts = [];
            
            if (!signals || signals.length === 0) return { prediction: (Date.now() % 2 === 0) ? "BIG" : "SMALL", confidence: 0.35, logic: "EnsV6-NoSignals" };

            signals.forEach(signal => {
                if (!signal || signal.prediction === null || typeof signal.confidence !== 'number' || typeof signal.weight !== 'number') {
                    // Allow Rhythm type to pass even if prediction is null, as it's for context
                    if (signal && signal.type === "Rhythm" && typeof signal.confidence === 'number' && typeof signal.weight === 'number') {
                        // Don't add to bigScore/smallScore, but allow its logic to be part of the final logic string
                    } else {
                        return; 
                    }
                }

                let currentWeight = signal.weight;
                // Contextual Adjustments (Volatility & Rhythm)
                if (volatilityContext) {
                    if (volatilityContext.volatilityScore > 0.70) { 
                        if (signal.type === "Trend" && signal.confidence > 0.60) currentWeight *= 0.50; 
                        if (signal.type === "Recency") currentWeight *= 1.35; 
                        if (signal.type === "CP") currentWeight *= 0.60; 
                    } else if (volatilityContext.consistencyStreak >= 3) { 
                        if (signal.type === "Trend" && signal.confidence > 0.50) currentWeight *= 1.45; 
                        if (signal.type === "Recency" && volatilityContext.consistencyStreak >=4) currentWeight *= 1.30; 
                    }
                }
                if (rhythmContext) {
                    if (rhythmContext.phase === "STREAKY" && signal.type === "Trend") currentWeight *= 1.2;
                    else if (rhythmContext.phase === "CHOPPY" && (signal.type === "Trend" || signal.type === "CP")) currentWeight *= 0.7; 
                    else if (rhythmContext.phase === "CHOPPY" && signal.type === "Recency") currentWeight *= 1.15; 
                }

                if (isExtremeLevelReached && streakTypeToBreak) {
                    if (signal.prediction === streakTypeToBreak) {
                        currentWeight *= 0.05; 
                        signal.confidence *= 0.3; 
                    } else { 
                        currentWeight *= 2.8; 
                        signal.confidence = Math.min(0.95, signal.confidence * 1.4); 
                    }
                }

                const scoreContribution = signal.confidence * currentWeight;
                if (signal.prediction === "BIG") {
                    bigScore += scoreContribution;
                } else if (signal.prediction === "SMALL") {
                    smallScore += scoreContribution;
                }
                logicParts.push(`${signal.type.substring(0,3)}:${signal.prediction ? signal.prediction[0]:'N'}(${signal.confidence.toFixed(1)}*${currentWeight.toFixed(1)})`);
            });

            if (bigScore === 0 && smallScore === 0) { 
                const breakPrediction = isExtremeLevelReached && streakTypeToBreak ? (streakTypeToBreak === "BIG" ? "SMALL" : "BIG") : (Date.now() % 2 === 0 ? "BIG" : "SMALL");
                return { prediction: breakPrediction, confidence: 0.35, logic: `EnsV6-ZeroScores${isExtremeLevelReached ? 'ExtBrk' : ''}` };
            }

            const finalPrediction = bigScore >= smallScore ? "BIG" : "SMALL";
            
            const totalScore = bigScore + smallScore;
            let finalConfidence = totalScore > 0 ? (Math.abs(bigScore - smallScore) / totalScore) : 0;
            finalConfidence = 0.38 + (finalConfidence * 0.57); 

            const agreeingSignals = signals.filter(s => s.prediction === finalPrediction);
            const numAgreeing = agreeingSignals.length;
            const numTotalValidSignals = signals.filter(s => s.prediction !== null).length;

            if (numTotalValidSignals > 0) {
                const agreementRatio = numAgreeing / numTotalValidSignals;
                if (agreementRatio >= 0.70 && numTotalValidSignals >= 2) { 
                    const avgConfidenceOfAgreeing = agreeingSignals.reduce((sum, s) => sum + s.confidence, 0) / (numAgreeing || 1);
                    finalConfidence = Math.min(0.95, (finalConfidence + avgConfidenceOfAgreeing) / 1.7); 
                } else if (agreementRatio <= 0.30 && numTotalValidSignals >= 3) { 
                    finalConfidence = Math.max(0.35, finalConfidence * 0.55); 
                }
            }
            
            if (isExtremeLevelReached) { 
                finalConfidence = Math.min(finalConfidence, 0.40); 
                logicParts.push("EXTREME_FORCE_ADJ");
            }

            return { 
                prediction: finalPrediction, 
                confidence: parseFloat(Math.max(0.35, Math.min(0.95, finalConfidence)).toFixed(2)), 
                logic: `Ens(${logicParts.join('|').substring(0,35)})` 
            };
        }
        function advancedPredictionAlgorithm(periodShortToPredict, historyForLogic, currentAlgoWinLevel, isExtremeLevel) { /* ... (same as original) ... */
            const resolvedHistory = historyForLogic.filter(h => h.status !== "Pending" && typeof h.result === 'number' && (h.resultType === "BIG" || h.resultType === "SMALL")).slice(0, 25); 

            let signals = [];
            if (resolvedHistory.length >= 1) { 
                signals.push(detailedTrendAnalysisModule(resolvedHistory, 7));
                signals.push(dominanceAnalysisModule(resolvedHistory, 5, 1.1)); 
                signals.push(dominanceAnalysisModule(resolvedHistory, 12, 0.9)); 
                signals.push(recencyBiasAnalysisModule(resolvedHistory)); 
                signals.push(complexPatternDetectorModule(resolvedHistory, 6));
            }
            
            const volatilityContext = volatilityAndConsistencyModule(resolvedHistory, 8);
            const rhythmContext = rhythmAndCycleAnalysisModule(resolvedHistory, 15);
            signals.push({prediction: null, confidence: rhythmContext.confidence, weight: rhythmContext.weight, type: "Rhythm", logic: rhythmContext.logic}); 
            
            let streakTypeToBreak = null;
            let predictionToBreakStreak = null;
            if(isExtremeLevel && currentAIPrediction && currentAIPrediction.prediction) {
                 streakTypeToBreak = currentAlgoWinLevel > 0 ? currentAIPrediction.prediction : (currentAIPrediction.prediction === "BIG" ? "SMALL" : "BIG");
                 predictionToBreakStreak = streakTypeToBreak === "BIG" ? "SMALL" : "BIG";
                 console.log(`Extreme Level (${currentAlgoWinLevel}). Current streak type: ${currentAIPrediction.prediction}. Aiming to break with: ${predictionToBreakStreak}`);
            }

            let combinedPredictionObj;
            if (signals.filter(s => s.prediction !== null || s.type === "Rhythm").length > 0) { 
                combinedPredictionObj = getWeightedEnsemblePrediction(signals, volatilityContext, rhythmContext, isExtremeLevel, streakTypeToBreak);
            } else {
                const breakPrediction = isExtremeLevel && predictionToBreakStreak ? predictionToBreakStreak : (Date.now() % 2 === 0 ? "BIG" : "SMALL");
                combinedPredictionObj = { prediction: breakPrediction, confidence: 0.38, logic: `FallbackNoSig${isExtremeLevel ? 'ExtBrk':''}` };
            }
            
            let finalPrediction = combinedPredictionObj.prediction;
            let finalConfidence = combinedPredictionObj.confidence;
            let finalLogic = combinedPredictionObj.logic;

            if (isExtremeLevel && predictionToBreakStreak && finalPrediction !== predictionToBreakStreak && !finalLogic.includes("FLIP")) { 
                console.log(`ExtremeLvlOverride V6: Ensemble picked ${finalPrediction}, but forcing ${predictionToBreakStreak} due to level ${currentAlgoWinLevel}.`);
                finalPrediction = predictionToBreakStreak;
                finalConfidence = 0.37; 
                finalLogic = `ExtLvlOVER(${currentAlgoWinLevel})!${predictionToBreakStreak[0]}`;
            }

            if (isExtremeLevel) { 
                 const typeThatCausedExtreme = currentAlgoWinLevel > 0 ? 
                        (currentAIPrediction?.prediction) : 
                        (currentAIPrediction?.prediction === "BIG" ? "SMALL" : "BIG");

                if (typeThatCausedExtreme && finalPrediction === typeThatCausedExtreme) { 
                    console.warn(`ULTRA FORCE FLIP V6: Ensemble still predicted ${finalPrediction} at extreme level ${currentAlgoWinLevel}. Forcing FLIP for period ${periodShortToPredict}.`);
                    finalPrediction = finalPrediction === "BIG" ? "SMALL" : "BIG";
                    finalConfidence = 0.35; 
                    finalLogic = `FORCE_FLIP!!(${currentAlgoWinLevel})`;
                }
            }
            
            const oppositeNum = getOppositeNumber(finalPrediction);

            return {
                ...DEFAULT_PREDICTION_ITEM_STRUCTURE,
                id: periodShortToPredict + "_ai_" + Date.now(), period: periodShortToPredict,
                predictionTime: new Date().toISOString(), prediction: finalPrediction,
                oppositeNumber: oppositeNum, confidence: finalConfidence,
                logic: finalLogic.substring(0, 50), status: "Pending",
            };
        }
        function updateModuleEffectiveness(logicString, predictionStatus) { /* ... (same as original) ... */
            if (!logicString) return;
            let mainModuleType = null;
            if (logicString.startsWith("Ens(")) {
                const ensContent = logicString.substring(4, logicString.indexOf(')'));
                const firstSignal = ensContent.split('|')[0];
                if (firstSignal && firstSignal.includes(':')) {
                    mainModuleType = firstSignal.substring(0, firstSignal.indexOf(':'));
                }
            } else if (logicString.includes("FLIP") || logicString.includes("ExtLvl")) {
                return; 
            } else { 
                 const parts = logicString.match(/^([A-Za-z]+)/); 
                 if (parts && parts[1]) {
                    const keyMap = { "Tr": "Trend", "Dom": "Dominance", "Rec": "Recency", "CP": "CP", "Vol": "Volatility", "Rhy": "Rhythm" };
                    mainModuleType = keyMap[parts[1]];
                 }
            }

            if (mainModuleType && moduleEffectiveness[mainModuleType]) {
                if (predictionStatus === "WIN") {
                    moduleEffectiveness[mainModuleType].wins = (moduleEffectiveness[mainModuleType].wins || 0) + 1;
                } else if (predictionStatus === "LOSS") {
                    moduleEffectiveness[mainModuleType].losses = (moduleEffectiveness[mainModuleType].losses || 0) + 1;
                }
        
                const total = moduleEffectiveness[mainModuleType].wins + moduleEffectiveness[mainModuleType].losses;
                if (total >= 3) { 
                    let ratio = moduleEffectiveness[mainModuleType].wins / total;
                    let currentMultiplier = moduleEffectiveness[mainModuleType].weightMultiplier || 1.0;

                    if (ratio > 0.60) currentMultiplier = Math.min(1.35, currentMultiplier + 0.07); 
                    else if (ratio < 0.40) currentMultiplier = Math.max(0.65, currentMultiplier - 0.07); 
                    else if (ratio >= 0.45 && ratio <= 0.55) currentMultiplier = 1.0; 
                    
                    moduleEffectiveness[mainModuleType].weightMultiplier = parseFloat(currentMultiplier.toFixed(2));
        
                    if (total >= EFFECTIVENESS_MEMORY) { 
                        moduleEffectiveness[mainModuleType].wins = Math.round(moduleEffectiveness[mainModuleType].wins / 2); 
                        moduleEffectiveness[mainModuleType].losses = Math.round(moduleEffectiveness[mainModuleType].losses / 2);
                        console.log(`Effectiveness memory reset for ${mainModuleType}`);
                    }
                }
                 console.log(`Effectiveness for ${mainModuleType}: W=${moduleEffectiveness[mainModuleType].wins}, L=${moduleEffectiveness[mainModuleType].losses}, Multiplier=${moduleEffectiveness[mainModuleType].weightMultiplier}`);
            }
            localStorage.setItem(APP_STORAGE_PREFIX + 'moduleEffectiveness', JSON.stringify(moduleEffectiveness));
        }
        async function updateGameData() { /* ... (same as original, with the login/server status checks) ... */
            const isLoggedIn = !!localStorage.getItem(PREDICTOR_LOGGED_IN_DEVICE_ID_KEY);
            if (isUpdatingData || !isLoggedIn || !isPredictorServerOn) {
                 if (!isLoggedIn) console.log("UpdateGameData skipped: User not logged in.");
                 else if (!isPredictorServerOn) console.log("UpdateGameData skipped: Predictor server is OFF.");
                 else if (isUpdatingData) console.log("UpdateGameData skipped: Already updating.");
                return;
            }
            isUpdatingData = true;
            // ... rest of the original updateGameData logic ...
            const apiResults = await fetchGameResultFromAPI();
            
            if (apiResults && apiResults.length > 0) {
                let newResultsProcessedThisCycle = false;
                for (const apiResult of apiResults.slice().reverse()) {
                    if (!apiResult || typeof apiResult.issueNumber !== 'string' || typeof apiResult.number === 'undefined') continue;
                    const fullPeriod = apiResult.issueNumber;
                    const periodShort = fullPeriod.slice(-3); 
                    const apiResultNumber = parseInt(apiResult.number);

                    if (isNaN(apiResultNumber) || apiResultNumber < 0 || apiResultNumber > 9) continue;

                    const existingEntryIndex = allHistory.findIndex(item => item.period === periodShort && item.fullPeriod === fullPeriod);
                    let entryToUpdate;

                    if (existingEntryIndex !== -1) {
                        entryToUpdate = { ...allHistory[existingEntryIndex] };
                        if (entryToUpdate.status !== "Pending") {
                            if(!entryToUpdate.fullPeriod) entryToUpdate.fullPeriod = fullPeriod;
                            if(entryToUpdate.result === null) entryToUpdate.result = apiResultNumber;
                            allHistory[existingEntryIndex] = entryToUpdate;
                            continue; 
                        }
                    } else { 
                        entryToUpdate = {
                            ...DEFAULT_PREDICTION_ITEM_STRUCTURE, id: periodShort + "_api_" + Date.now(),
                            period: periodShort, fullPeriod: fullPeriod,
                            predictionTime: new Date(apiResult.time || Date.now()).toISOString(),
                            status: "API_RESULT_ONLY", 
                        };
                    }
                    
                    entryToUpdate.result = apiResultNumber;
                    entryToUpdate.resultType = apiResultNumber >= 5 ? "BIG" : "SMALL";
                    if (apiResultNumber === 0 || apiResultNumber === 5) entryToUpdate.resultColor = apiResultNumber === 0 ? "REDVIOLET" : "GREENVIOLET";
                    else if (apiResultNumber % 2 === 0) entryToUpdate.resultColor = "RED";
                    else entryToUpdate.resultColor = "GREEN";

                    if (entryToUpdate.status === "Pending" && entryToUpdate.prediction && (entryToUpdate.prediction === "BIG" || entryToUpdate.prediction === "SMALL")) {
                        if (entryToUpdate.prediction === entryToUpdate.resultType) {
                            entryToUpdate.status = "WIN";
                            localWinLevel = Math.min(localWinLevel + 1, MAX_WIN_LEVEL_STREAK * 2); 
                        } else {
                            entryToUpdate.status = "LOSS";
                            localWinLevel = Math.max(localWinLevel - 1, -MAX_WIN_LEVEL_STREAK * 2); 
                        }
                        updateModuleEffectiveness(entryToUpdate.logic, entryToUpdate.status); 
                    } else if (entryToUpdate.status === "Pending") { 
                        entryToUpdate.status = "API_RESULT_ONLY"; 
                        entryToUpdate.prediction = null; 
                    }
                    
                    if (existingEntryIndex !== -1) allHistory[existingEntryIndex] = entryToUpdate;
                    else allHistory.unshift(entryToUpdate);
                    newResultsProcessedThisCycle = true;
                }
                if (newResultsProcessedThisCycle) {
                    lastAPIFetchedPeriodFull = apiResults[0].issueNumber; 
                    localStorage.setItem(APP_STORAGE_PREFIX + 'lastAPIFetchedPeriodFull', lastAPIFetchedPeriodFull);
                }
            }

            if (lastAPIFetchedPeriodFull) {
                const nextPeriodFull = (BigInt(lastAPIFetchedPeriodFull) + 1n).toString();
                const nextPeriodShort = nextPeriodFull.slice(-3); 
                const existingPendingForNext = allHistory.find(p => p.period === nextPeriodShort && p.status === "Pending" && p.prediction);

                if (!existingPendingForNext) {
                    let effectiveWinLevel = localWinLevel;
                    let isExtremeLevel = Math.abs(localWinLevel) >= MAX_WIN_LEVEL_STREAK;

                    const lastResolvedAIPrediction = allHistory.find(p => p.prediction && p.fullPeriod === lastAPIFetchedPeriodFull && (p.status === "WIN" || p.status === "LOSS"));
                    if (lastResolvedAIPrediction && lastResolvedAIPrediction.logic && 
                        (lastResolvedAIPrediction.logic.toLowerCase().includes('flip') || lastResolvedAIPrediction.logic.toLowerCase().includes('extlvl') || lastResolvedAIPrediction.logic.toLowerCase().includes('over') ) && 
                        isExtremeLevel) { 
                       console.log(`Win/Loss Level (${localWinLevel}) was extreme, and last pred was a system intervention. Resetting to 0 for Period: ${nextPeriodShort}.`);
                       localWinLevel = 0; 
                       effectiveWinLevel = 0;
                       isExtremeLevel = false; 
                    }
                    
                    const newAIEntry = advancedPredictionAlgorithm(nextPeriodShort, allHistory, effectiveWinLevel, isExtremeLevel);
                    newAIEntry.fullPeriod = nextPeriodFull;
                    
                    const existingApiOnlyIndex = allHistory.findIndex(p => p.period === newAIEntry.period && p.status === "API_RESULT_ONLY");
                    if (existingApiOnlyIndex !== -1) {
                        allHistory[existingApiOnlyIndex] = { ...allHistory[existingApiOnlyIndex], ...newAIEntry, status: "Pending" }; 
                    } else {
                         allHistory.unshift(newAIEntry); 
                    }
                    
                    currentAIPrediction = newAIEntry;
                    localStorage.setItem(APP_STORAGE_PREFIX + 'currentAIPrediction', JSON.stringify(currentAIPrediction));
                }
            }
            
            allHistory.sort((a, b) => { 
                const periodNumA = a.fullPeriod ? BigInt(a.fullPeriod) : (a.period ? BigInt("202401010" + a.period) : 0); 
                const periodNumB = b.fullPeriod ? BigInt(b.fullPeriod) : (b.period ? BigInt("202401010" + b.period) : 0);
                if (periodNumB !== periodNumA) return Number(periodNumB - periodNumA);
                const timeA = a.predictionTime ? new Date(a.predictionTime).getTime() : 0;
                const timeB = b.predictionTime ? new Date(b.predictionTime).getTime() : 0;
                return timeB - timeA;
            });
            
            allHistory = allHistory.filter(item => 
                item.status === "API_RESULT_ONLY" || 
                item.status === "Pending" || 
                (item.prediction && (item.prediction === "BIG" || item.prediction === "SMALL") && (item.status === "WIN" || item.status === "LOSS"))
            );

            if (allHistory.length > MAX_HISTORY_ITEMS_STORAGE) {
                allHistory = allHistory.slice(0, MAX_HISTORY_ITEMS_STORAGE);
            }

            saveAllData();
            updateUI(); 
            checkSpecialConditions();
            isUpdatingData = false;
        }
        function saveAllData() { /* ... (same as original) ... */
            localStorage.setItem(APP_STORAGE_PREFIX + 'allHistory', JSON.stringify(allHistory));
            localStorage.setItem(APP_STORAGE_PREFIX + 'localWinLevel', localWinLevel.toString());
            localStorage.setItem(APP_STORAGE_PREFIX + 'moduleEffectiveness', JSON.stringify(moduleEffectiveness));
        }
        function renderHistory() { /* ... (same as original, ensure it uses `allHistory`) ... */
            if (!historyContainerEl) return;
            const validDisplayItems = allHistory.filter(item => 
                item.prediction && (item.prediction === "BIG" || item.prediction === "SMALL")
            ).slice(0, MAX_HISTORY_ITEMS_DISPLAY);


            if (validDisplayItems.length === 0) {
                historyContainerEl.innerHTML = `<p class="text-slate-400 text-center py-5 text-xs">No AI predictions in history yet.</p>`;
                return;
            }
            historyContainerEl.innerHTML = validDisplayItems.map((item, index) => {
                let sbc = 'badge-pending'; let ibc = 'history-item-pending';
                let dT = item.prediction; 
                let confVal = typeof item.confidence === 'number' ? item.confidence : 0;
                let cT = `(${(confVal * 100).toFixed(0)}%)`;
                
                let rD = item.result !== null ? `${item.result} (${item.resultType || ''})` : 'Wait...'; 
                let oNT = item.oppositeNumber !== null ? `Op:${item.oppositeNumber}` : '';

                if (item.status === 'WIN') { sbc = 'badge-win'; ibc = 'history-item-win'; }
                else if (item.status === 'LOSS') { sbc = 'badge-loss'; ibc = 'history-item-loss'; }
                
                const pD = item.period || (item.fullPeriod ? item.fullPeriod.slice(-3) : '-'); 
                const lS = item.logic ? item.logic.substring(0,10)+(item.logic.length > 10 ? '…' : '') : 'N/A';

                return `
                <div class="history-item ${ibc} bg-slate-800/50 p-2 rounded-md shadow-xs flex items-center gap-1.5 text-xs" 
                     data-id="${item.id}" style="animation: fadeIn 0.15s ease-out ${index * 0.02}s backwards;">
                    <div class="font-semibold text-slate-300 w-10 text-center py-1">${pD}</div>
                    <div class="flex-1 grid grid-cols-4 gap-1 items-center">
                        <div class="truncate py-1">
                            <p class="font-medium text-slate-200">${dT} <span class="text-slate-400 text-[0.6rem]">${cT}</span></p>
                            <p class="text-slate-500 text-[0.6rem]">${oNT}</p>
                        </div>
                         <div class="truncate text-slate-400 text-[0.6rem] py-1" title="${item.logic || ''}">${lS}</div>
                        <div class="font-medium text-slate-200 truncate py-1">${rD}</div>
                        <div class="text-right py-1"> <span class="premium-badge ${sbc}">${item.status}</span> </div>
                    </div>
                    <button class="delete-btn text-slate-500 hover:text-red-400 p-1 rounded-full ml-1" 
                            onclick="handleDeletePrediction('${item.id}')" title="Delete Prediction">
                        <i class="fas fa-times text-[0.7rem]"></i>
                    </button>
                </div>`;
            }).join('');
        }
        function updateUI() { /* ... (same as original, ensure it uses `allHistory` and `currentAIPrediction`) ... */
            let displayPeriod = "-";
            if (currentAIPrediction && currentAIPrediction.fullPeriod) {
                displayPeriod = currentAIPrediction.fullPeriod.slice(-3); 
            } else if (lastAPIFetchedPeriodFull) {
                 displayPeriod = (BigInt(lastAPIFetchedPeriodFull) + 1n).toString().slice(-3); 
            } else {
                const latestAnyItem = allHistory.find(item => item.fullPeriod || item.period); 
                if (latestAnyItem && latestAnyItem.fullPeriod) displayPeriod = latestAnyItem.fullPeriod.slice(-3);
                else if (latestAnyItem && latestAnyItem.period) displayPeriod = latestAnyItem.period; 
            }
            if (currentPeriodEl) currentPeriodEl.textContent = displayPeriod;

            if (currentPredictionEl) {
                if (currentAIPrediction && currentAIPrediction.status === "Pending" && (currentAIPrediction.prediction === "BIG" || currentAIPrediction.prediction === "SMALL")) {
                    let confVal = typeof currentAIPrediction.confidence === 'number' ? currentAIPrediction.confidence : 0;
                    currentPredictionEl.innerHTML = `<i class="fas fa-magic mr-1 opacity-70 text-sm"></i> ${currentAIPrediction.prediction} <span class="text-xs opacity-80">(${(confVal * 100).toFixed(0)}%)</span>`;
                    if(activeLogicDisplayEl) {
                        let displayLogic = "Ensemble"; 
                        if (currentAIPrediction.logic) {
                            if (currentAIPrediction.logic.toLowerCase().includes("flip") || currentAIPrediction.logic.toLowerCase().includes("extlvl") || currentAIPrediction.logic.toLowerCase().includes("over")) displayLogic = "Level Adjust"; 
                            else if (currentAIPrediction.logic.toLowerCase().includes("ens(")) displayLogic = "Ensemble V6"; 
                        }
                        activeLogicDisplayEl.textContent = displayLogic;
                    }
                } else {
                    currentPredictionEl.innerHTML = `<i class="fas fa-hourglass-start mr-1 opacity-70 text-sm"></i> Wait...`;
                     if(activeLogicDisplayEl) activeLogicDisplayEl.textContent = 'N/A';
                }
            }

            const latestResolvedItem = allHistory.find(p => p.status === "WIN" || p.status === "LOSS" || p.status === "API_RESULT_ONLY");
            if (currentResultEl && latestResolvedItem) {
                currentResultEl.textContent = `${latestResolvedItem.result !== null ? latestResolvedItem.result : ''} (${latestResolvedItem.resultType || ''})`;
                if (resultIconEl) {
                    if (latestResolvedItem.status === 'WIN') resultIconEl.innerHTML = '<i class="fas fa-trophy text-yellow-300"></i>';
                    else if (latestResolvedItem.status === 'LOSS') resultIconEl.innerHTML = '<i class="fas fa-heart-crack text-red-300"></i>';
                    else if (latestResolvedItem.status === 'API_RESULT_ONLY') resultIconEl.innerHTML = '<i class="fas fa-receipt text-indigo-300"></i>'; 
                    else resultIconEl.innerHTML = '<i class="fas fa-spinner fa-spin text-sky-200"></i>'; 
                }
            } else if (currentResultEl) {
                currentResultEl.textContent = "-"; if (resultIconEl) resultIconEl.innerHTML = "";
            }

            const stats = calculateOverallStats(allHistory);
            if (winRateEl) winRateEl.textContent = `${stats.winRate}%`;
            if (totalWinBetsEl) totalWinBetsEl.textContent = stats.totalWins;
            if (totalLossBetsEl) totalLossBetsEl.textContent = stats.totalLosses;
            if (localWinLevelDisplayEl) localWinLevelDisplayEl.textContent = localWinLevel;

            const freqHistory = allHistory.filter(p => p.status !== "Pending" && p.resultType).map(p => p.resultType);
            const {mostFrequent, leastFrequent} = getFrequencyStats(freqHistory);
            if (mostFrequentEl) mostFrequentEl.textContent = mostFrequent || '-';
            if (leastFrequentEl) leastFrequentEl.textContent = leastFrequent || '-';
            
            renderHistory(); 
        }
        function calculateOverallStats(history) { /* ... (same as original) ... */
            const aiPredictionsResolved = history.filter(p => (p.status === "WIN" || p.status === "LOSS") && p.prediction && (p.prediction === "BIG" || p.prediction === "SMALL"));
            const wins = aiPredictionsResolved.filter(p => p.status === "WIN").length;
            const losses = aiPredictionsResolved.filter(p => p.status === "LOSS").length;
            const total = wins + losses;
            const winRate = total > 0 ? ((wins / total) * 100).toFixed(1) : "0.0";
            return { winRate, totalWins: wins, totalLosses: losses, totalCompleted: total };
        }
        function getFrequencyStats(items) { /* ... (same as original) ... */
            if (!items || items.length === 0) return { mostFrequent: null, leastFrequent: null };
            const frequencyMap = items.reduce((acc, val) => { acc[val] = (acc[val] || 0) + 1; return acc; }, {});
            const sortedFrequencies = Object.entries(frequencyMap).sort(([,a],[,b]) => b-a);
            return {
                mostFrequent: sortedFrequencies.length > 0 ? sortedFrequencies[0][0] : null,
                leastFrequent: sortedFrequencies.length > 0 ? sortedFrequencies[sortedFrequencies.length - 1][0] : null,
            };
        }
        function handleDeletePrediction(itemId) { /* ... (same as original) ... */
            allHistory = allHistory.filter(p => p.id !== itemId);
            if (currentAIPrediction && currentAIPrediction.id === itemId) {
                currentAIPrediction = null; 
                localStorage.removeItem(APP_STORAGE_PREFIX + 'currentAIPrediction');
            }
            saveAllData(); updateUI();
        }
        function handleClearHistory() { /* ... (same as original) ... */ clearHistoryModal.style.display = 'block'; }
        function confirmClearHistoryAction() { /* ... (same as original) ... */
            allHistory = []; currentAIPrediction = null; localWinLevel = 0; lastAPIFetchedPeriodFull = null;
            localStorage.removeItem(APP_STORAGE_PREFIX + 'allHistory');
            localStorage.removeItem(APP_STORAGE_PREFIX + 'currentAIPrediction');
            localStorage.removeItem(APP_STORAGE_PREFIX + 'localWinLevel');
            localStorage.removeItem(APP_STORAGE_PREFIX + 'lastAPIFetchedPeriodFull');
            localStorage.removeItem(APP_STORAGE_PREFIX + 'lossTriggered');
            localStorage.removeItem(APP_STORAGE_PREFIX + 'winTriggered'); // Clear winTriggered as well
            moduleEffectiveness = { Trend: { wins: 0, losses: 0, weightMultiplier: 1.0 }, Dominance: { wins: 0, losses: 0, weightMultiplier: 1.0 }, Recency: { wins: 0, losses: 0, weightMultiplier: 1.0 }, CP: { wins: 0, losses: 0, weightMultiplier: 1.0 }, Rhythm: { wins: 0, losses: 0, weightMultiplier: 1.0 }, Volatility: { wins: 0, losses: 0, weightMultiplier: 1.0 } };
            saveAllData(); 
            updateUI(); clearHistoryModal.style.display = 'none';
        }
        function checkSpecialConditions() { 
            // Removed the auto-logout condition tied to winTriggered and server status,
            // as server status logout is handled directly in fetchPredictorServerStatus.
            if (localStorage.getItem(APP_STORAGE_PREFIX + 'lossTriggered') === 'true') return;
            const ourResolvedPredictions = allHistory.filter(p => (p.status === "WIN" || p.status === "LOSS") && p.prediction).slice(0,5);
            if (ourResolvedPredictions.length === 5 && ourResolvedPredictions.every(p => p.status === "LOSS")) {
                const telegramMessage = encodeURIComponent('Sir, NEWROX AI has 5 consecutive losses. Please check.');
                localStorage.setItem(APP_STORAGE_PREFIX + 'lossTriggered', 'true');
                alert(`NEWROX AI: 5 consecutive losses. Contact @NEWROXAI.`);
                return; 
            }
            // Win popup condition remains
            if (localStorage.getItem(APP_STORAGE_PREFIX + 'winTriggered') === 'true') return;
            const { winRate, totalCompleted } = calculateOverallStats(allHistory);
            if (totalCompleted >= 15 && parseFloat(winRate) >= 60) {
                if (winRatePopup) winRatePopup.style.display = 'block';
                localStorage.setItem(APP_STORAGE_PREFIX + 'winTriggered', 'true');
            }
        }

        // --- Event Listeners and Initialization ---
        document.addEventListener('DOMContentLoaded', function() {
            checkPredictorLoginStatus(); 

            if(predictorLogoutBtn) predictorLogoutBtn.addEventListener('click', () => handlePredictorLogout("You have been logged out."));
            if(copyGeneratedIdBtn) copyGeneratedIdBtn.addEventListener('click', copyGeneratedDeviceId);
            
            pageButtons.forEach(button => button.addEventListener('click', () => switchPage(button.dataset.page)));
            if (clearHistoryBtn) clearHistoryBtn.addEventListener('click', handleClearHistory);
            if (confirmClearBtn) confirmClearBtn.addEventListener('click', confirmClearHistoryAction);
            if (cancelClearBtn) cancelClearBtn.addEventListener('click', () => clearHistoryModal.style.display = 'none');
            if (closeWinPopupBtn) closeWinPopupBtn.addEventListener('click', () => winRatePopup.style.display = 'none');
            
            const lastActiveTab = localStorage.getItem(APP_STORAGE_PREFIX + 'active_tab');
            switchPage(lastActiveTab || 'main'); 

            setInterval(updateGameData, API_FETCH_INTERVAL);
        });
    </script>
</body>
</html>
